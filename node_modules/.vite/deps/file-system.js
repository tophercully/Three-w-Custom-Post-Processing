import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/utils-extend/index.js
var require_utils_extend = __commonJS({
  "node_modules/utils-extend/index.js"(exports) {
    var util = require_util();
    var toString = Object.prototype.toString;
    var isWindows = process.platform === "win32";
    function isObject(value) {
      return toString.call(value) === "[object Object]";
    }
    ["Function", "String", "Number", "Date", "RegExp"].forEach(function(item) {
      exports["is" + item] = function(value) {
        return toString.call(value) === "[object " + item + "]";
      };
    });
    function extend(target, source) {
      var value;
      for (var key in source) {
        value = source[key];
        if (Array.isArray(value)) {
          if (!Array.isArray(target[key])) {
            target[key] = [];
          }
          extend(target[key], value);
        } else if (isObject(value)) {
          if (!isObject(target[key])) {
            target[key] = {};
          }
          extend(target[key], value);
        } else {
          target[key] = value;
        }
      }
      return target;
    }
    extend(exports, util);
    exports.isObject = isObject;
    exports.extend = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      var target = args.shift();
      args.forEach(function(item) {
        extend(target, item);
      });
      return target;
    };
    exports.isArray = Array.isArray;
    exports.isUndefined = function(value) {
      return typeof value == "undefined";
    };
    exports.noop = function() {
    };
    exports.unique = function(array) {
      var result = [];
      array.forEach(function(item) {
        if (result.indexOf(item) == -1) {
          result.push(item);
        }
      });
      return result;
    };
    exports.escape = function(value) {
      return String(value).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    };
    exports.unescape = function(value) {
      return String(value).replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
    };
    exports.hrtime = function(time) {
      if (time) {
        var spend = process.hrtime(time);
        spend = (spend[0] + spend[1] / 1e9) * 1e3 + "ms";
        return spend;
      } else {
        return process.hrtime();
      }
    };
    exports.pick = function(obj, iteratee) {
      var result = {};
      if (exports.isFunction(iteratee)) {
        for (var key in obj) {
          var value = obj[key];
          if (iteratee(value, key, obj)) {
            result[key] = value;
          }
        }
      } else {
        var keys = Array.prototype.slice.call(arguments, 1);
        keys.forEach(function(key2) {
          if (key2 in obj) {
            result[key2] = obj[key2];
          }
        });
      }
      return result;
    };
    exports.path = {};
    if (isWindows) {
      splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      exports.path.isAbsolute = function(filepath) {
        var result = splitDeviceRe.exec(filepath), device = result[1] || "", isUnc = !!device && device.charAt(1) !== ":";
        return !!result[2] || isUnc;
      };
      exports.path.unixifyPath = function(filepath) {
        return filepath.replace(/\\/g, "/");
      };
    } else {
      exports.path.isAbsolute = function(filepath) {
        return filepath.charAt(0) === "/";
      };
      exports.path.unixifyPath = function(filepath) {
        return filepath;
      };
    }
    var splitDeviceRe;
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/file-match/file-match.js
var require_file_match = __commonJS({
  "node_modules/file-match/file-match.js"(exports, module) {
    var util = require_utils_extend();
    function fileMatch(filter, ignore) {
      if (filter === null) {
        return function() {
          return true;
        };
      } else if (filter === "" || util.isArray(filter) && !filter.length) {
        return function() {
          return false;
        };
      }
      if (util.isString(filter)) {
        filter = [filter];
      }
      var match = [];
      var negate = [];
      var isIgnore = ignore ? "i" : "";
      filter.forEach(function(item) {
        var isNegate = item.indexOf("!") === 0;
        item = item.replace(/^!/, "").replace(/\*(?![\/*])/, "[^/]*?").replace("**/", "([^/]+/)*").replace(/\{([^\}]+)\}/g, function($1, $2) {
          var collection = $2.split(",");
          var length = collection.length;
          var result = "(?:";
          collection.forEach(function(item2, index) {
            result += "(" + item2.trim() + ")";
            if (index + 1 !== length) {
              result += "|";
            }
          });
          result += ")";
          return result;
        }).replace(/([\/\.])/g, "\\$1");
        item = "(^" + item + "$)";
        if (isNegate) {
          negate.push(item);
        } else {
          match.push(item);
        }
      });
      match = match.length ? new RegExp(match.join("|"), isIgnore) : null;
      negate = negate.length ? new RegExp(negate.join("|"), isIgnore) : null;
      return function(filepath) {
        filepath = util.path.unixifyPath(filepath);
        if (negate && negate.test(filepath)) {
          return false;
        }
        if (match && match.test(filepath)) {
          return true;
        }
        return false;
      };
    }
    module.exports = fileMatch;
  }
});

// node_modules/file-system/file-system.js
var require_file_system = __commonJS({
  "node_modules/file-system/file-system.js"(exports) {
    var fs = require_fs();
    var util = require_utils_extend();
    var path = require_path();
    var fileMatch = require_file_match();
    function checkCbAndOpts(options, callback) {
      if (util.isFunction(options)) {
        return {
          options: null,
          callback: options
        };
      } else if (util.isObject(options)) {
        return {
          options,
          callback
        };
      } else {
        return {
          options: null,
          callback: util.noop
        };
      }
    }
    function getExists(filepath) {
      var exists = fs.existsSync(filepath);
      if (exists) {
        return filepath;
      } else {
        return getExists(path.dirname(filepath));
      }
    }
    util.extend(exports, fs);
    exports.fs = fs;
    exports.fileMatch = fileMatch;
    exports.mkdir = function(filepath, mode, callback) {
      var root = getExists(filepath);
      var children = path.relative(root, filepath);
      if (util.isFunction(mode)) {
        callback = mode;
        mode = null;
      }
      if (!util.isFunction(callback)) {
        callback = util.noop;
      }
      mode = mode || 511;
      if (!children)
        return callback();
      children = children.split(path.sep);
      function create(filepath2) {
        if (create.count === children.length) {
          return callback();
        }
        filepath2 = path.join(filepath2, children[create.count]);
        fs.mkdir(filepath2, mode, function(err) {
          create.count++;
          create(filepath2);
        });
      }
      create.count = 0;
      create(root);
    };
    exports.mkdirSync = function(filepath, mode) {
      var root = getExists(filepath);
      var children = path.relative(root, filepath);
      if (!children)
        return;
      children = children.split(path.sep);
      children.forEach(function(item) {
        root = path.join(root, item);
        fs.mkdirSync(root, mode);
      });
    };
    exports.writeFile = function(filename, data, options, callback) {
      var result = checkCbAndOpts(options, callback);
      var dirname = path.dirname(filename);
      options = result.options;
      callback = result.callback;
      exports.mkdir(dirname, function() {
        fs.writeFile(filename, data, options, callback);
      });
    };
    exports.writeFileSync = function(filename, data, options) {
      var dirname = path.dirname(filename);
      exports.mkdirSync(dirname);
      fs.writeFileSync(filename, data, options);
    };
    exports.copyFile = function(srcpath, destpath, options) {
      options = util.extend({
        encoding: "utf8",
        done: util.noop
      }, options || {});
      if (!options.process) {
        options.encoding = null;
      }
      fs.readFile(srcpath, {
        encoding: options.encoding
      }, function(err, contents) {
        if (err)
          return options.done(err);
        if (options.process) {
          contents = options.process(contents);
        }
        exports.writeFile(destpath, contents, options, options.done);
      });
    };
    exports.copyFileSync = function(srcpath, destpath, options) {
      options = util.extend({
        encoding: "utf8"
      }, options || {});
      var contents;
      if (options.process) {
        contents = fs.readFileSync(srcpath, options);
        contents = options.process(contents, srcpath, options.relative);
        if (util.isObject(contents) && contents.filepath) {
          destpath = contents.filepath;
          contents = contents.contents;
        }
        exports.writeFileSync(destpath, contents, options);
      } else {
        contents = fs.readFileSync(srcpath);
        exports.writeFileSync(destpath, contents);
      }
    };
    exports.recurse = function(dirpath, filter, callback) {
      if (util.isFunction(filter)) {
        callback = filter;
        filter = null;
      }
      var filterCb = fileMatch(filter);
      var rootpath = dirpath;
      function recurse(dirpath2) {
        fs.readdir(dirpath2, function(err, files) {
          if (err)
            return callback(err);
          files.forEach(function(filename) {
            var filepath = path.join(dirpath2, filename);
            fs.stat(filepath, function(err2, stats) {
              var relative = path.relative(rootpath, filepath);
              var flag = filterCb(relative);
              if (stats.isDirectory()) {
                recurse(filepath);
                if (flag)
                  callback(filepath, relative);
              } else {
                if (flag)
                  callback(filepath, relative, filename);
              }
            });
          });
        });
      }
      recurse(dirpath);
    };
    exports.recurseSync = function(dirpath, filter, callback) {
      if (util.isFunction(filter)) {
        callback = filter;
        filter = null;
      }
      var filterCb = fileMatch(filter);
      var rootpath = dirpath;
      function recurse(dirpath2) {
        fs.readdirSync(dirpath2).forEach(function(filename) {
          var filepath = path.join(dirpath2, filename);
          var stats = fs.statSync(filepath);
          var relative = path.relative(rootpath, filepath);
          var flag = filterCb(relative);
          if (stats.isDirectory()) {
            recurse(filepath);
            if (flag)
              callback(filepath, relative);
          } else {
            if (flag)
              callback(filepath, relative, filename);
          }
        });
      }
      recurse(dirpath);
    };
    exports.rmdirSync = function(dirpath) {
      exports.recurseSync(dirpath, function(filepath, relative, filename) {
        if (filename) {
          fs.unlinkSync(filepath);
        } else {
          fs.rmdirSync(filepath);
        }
      });
      fs.rmdirSync(dirpath);
    };
    exports.copySync = function(dirpath, destpath, options) {
      options = util.extend({
        encoding: "utf8",
        filter: null,
        noProcess: ""
      }, options || {});
      var noProcessCb = fileMatch(options.noProcess);
      exports.mkdirSync(destpath);
      exports.recurseSync(dirpath, options.filter, function(filepath, relative, filename) {
        if (!filename)
          return;
        var newpath = path.join(destpath, relative);
        var opts = {
          relative
        };
        if (options.process && !noProcessCb(relative)) {
          opts.encoding = options.encoding;
          opts.process = options.process;
        }
        exports.copyFileSync(filepath, newpath, opts);
      });
    };
  }
});
export default require_file_system();
//# sourceMappingURL=file-system.js.map
